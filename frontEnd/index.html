<!DOCTYPE html>
<html>
<head>
    <title>Climate_ART</title>
    <style>
        body {
            margin: 0;
            padding-bottom: 3rem;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        #form {
            background: rgba(0, 0, 0, 0.15);
            padding: 0.25rem;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            height: 3rem;
            box-sizing: border-box;
            backdrop-filter: blur(10px);
        }
        #input{border: none;
            padding: 0 1rem;
            flex-grow: 1;
            border-radius: 2rem;
            margin: 0.25rem;
        }
        #input:focus {
            outline: none;
        }
        #form > button{
            background: #333;
            border: none;
            padding: 0 1rem;
            margin: 0.25rem;
            border-radius: 3px;
            outline: none;
            color: #fff;
        }
        messages {
            list-style-type: none;
            margin: 0;
            padding: 0; }
        #messages > li {
            padding: 0.5rem 1rem;
        }
        #messages > li:nth-child(odd) {
            background: #efefef;
        }
    </style>
</head>
<body>
<ul id="messages"></ul>
<form id="form" action="">
    <input id="input" autocomplete="off" />
    <button>Send</button>
</form>

<canvas id="canvas" width="600" height="600" style="border:solid black 1px;">
    Your browser does not support canvas element.
</canvas>


<script >
    var host = "<%= host %>";
    var port = "<%= port %>";
    console.log('Host: ' + host + ':' + port);
    const socket = new WebSocket('ws://' + host + ':' + port);

    let form = document.getElementById('form');
    let input = document.getElementById('input');
    let canvas = document.getElementById("canvas");
    let ongoingTouches = [];

    form.addEventListener('submit', function(e) {
        e.preventDefault();
        if (input.value) {
            socket.send(input.value);
            input.value = '';
        }
    });

    function handleStart(evt) {
        // Invoke the appropriate handler depending on the
        // number of touch points.
        switch (evt.touches.length) {
            case 1: handle_one_touch(evt); break;
            case 2: handle_two_touches(evt); break;
            default: console.log("Not supported"); break;
        }
    }

    function startup() {
        canvas.addEventListener("touchstart", handleStart, false);
        canvas.addEventListener("touchend", handleEnd, false);
        canvas.addEventListener("touchcancel", handleCancel, false);
        canvas.addEventListener("touchmove", handleMove, false);
    }

    function handle_one_touch(evt) {
        evt.preventDefault();
        console.log("touchstart.");
        sendCoordinates(evt.touches[0], 1);
    }

    function handle_two_touches(evt) {
        evt.preventDefault();
        console.log("touchstart.");
        sendCoordinates(evt.touches[0], 1);
        sendCoordinates(evt.touches[1], 2);
    }

    function sendCoordinates(touch, touchnum) {
        socket.send("touch: " + touch.clientX + " " + touch.clientY + " " + touchnum);
    }

    function handleMove(evt) {
        evt.preventDefault();
        socket.send("touch move");
        var touches = evt.changedTouches;
        for (var i = 0; i < touches.length; i++) {
            var idx = ongoingTouchIndexById(touches[i].identifier);

            if (idx >= 0) {
                console.log("continuing touch "+idx);

                socket.send("Move to " + ongoingTouches[idx].pageX + ", " + ongoingTouches[idx].pageY);
                socket.send("Line to " + touches[i].pageX + ", " + touches[i].pageY);

                ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
                console.log(".");
            } else {
                console.log("can't figure out which touch to continue");
            }
        }
    }

    function handleEnd(evt) {
        evt.preventDefault();
        log("touchend");
        var touches = evt.changedTouches;
        socket.send("touch end");
        for (var i = 0; i < touches.length; i++) {
            var idx = ongoingTouchIndexById(touches[i].identifier);

            if (idx >= 0) {
                ongoingTouches.splice(idx, 1);  // remove it; we're done
                socket.send("end touch");
            } else {
                console.log("can't figure out which touch to end");
            }
        }
    }

    function handleCancel(evt) {
        evt.preventDefault();
        console.log("touchcancel.");
        var touches = evt.changedTouches;
        socket.send("touch cancel");
        for (var i = 0; i < touches.length; i++) {
            var idx = ongoingTouchIndexById(touches[i].identifier);
            ongoingTouches.splice(idx, 1);  // remove it; we're done
            socket.send("touch canceled")
        }
    }

    function fixTouchMove( event )
    {
        return;
    }

    // Remove any previous listners as the page content is ajax loaded and body is never destroyed
    document.body.removeEventListener( "touchstart", fixTouchMove );
    document.body.addEventListener( "touchstart", fixTouchMove );

    document.addEventListener("DOMContentLoaded", startup);

    socket.onmessage = (event)=>{

        console.log(event)
        console.log(event.data)

        const item = document.createElement('li');
        item.textContent = event.data;
        messages.appendChild(item);
        window.scrollTo(0, document.body.scrollHeight);
    }

    /*
    *
     */
</script>

</body>
</html>
